# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.25.0
# source: users.sql
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from db.sqlcgen import models


GET_USER = """-- name: get_user \\:one
SELECT id, name, hashed_password, created_at FROM users WHERE name = :p1
"""


INSERT_USER = """-- name: insert_user \\:one
INSERT INTO users (name, hashed_password) VALUES (:p1, :p2) RETURNING id, name, hashed_password, created_at
"""


LIST_USERS = """-- name: list_users \\:many
SELECT id, name, hashed_password, created_at FROM users
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_user(self, *, name: Optional[str]) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(GET_USER), {"p1": name}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            name=row[1],
            hashed_password=row[2],
            created_at=row[3],
        )

    def insert_user(self, *, name: Optional[str], hashed_password: Optional[str]) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(INSERT_USER), {"p1": name, "p2": hashed_password}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            name=row[1],
            hashed_password=row[2],
            created_at=row[3],
        )

    def list_users(self) -> Iterator[models.User]:
        result = self._conn.execute(sqlalchemy.text(LIST_USERS))
        for row in result:
            yield models.User(
                id=row[0],
                name=row[1],
                hashed_password=row[2],
                created_at=row[3],
            )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_user(self, *, name: Optional[str]) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER), {"p1": name})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            name=row[1],
            hashed_password=row[2],
            created_at=row[3],
        )

    async def insert_user(self, *, name: Optional[str], hashed_password: Optional[str]) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_USER), {"p1": name, "p2": hashed_password})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            name=row[1],
            hashed_password=row[2],
            created_at=row[3],
        )

    async def list_users(self) -> AsyncIterator[models.User]:
        result = await self._conn.stream(sqlalchemy.text(LIST_USERS))
        async for row in result:
            yield models.User(
                id=row[0],
                name=row[1],
                hashed_password=row[2],
                created_at=row[3],
            )
